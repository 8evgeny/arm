.TH "xQueueOverwriteFromISR" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xQueueOverwriteFromISR \- xQueueOverwriteFromISR
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
queue\&. h 
.PP
.nf

 BaseType_t xQueueOverwriteFromISR(
                              QueueHandle_t xQueue,
                              const void * pvItemToQueue,
                              BaseType_t *pxHigherPriorityTaskWoken
                         );
   
.fi
.PP
.PP
A version of xQueueOverwrite() that can be used in an interrupt service routine (ISR)\&.
.PP
Only for use with queues that can hold a single item - so the queue is either empty or full\&.
.PP
Post an item on a queue\&. If the queue is already full then overwrite the value held in the queue\&. The item is queued by copy, not by reference\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.br
\fIpxHigherPriorityTaskWoken\fP xQueueOverwriteFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task\&. If xQueueOverwriteFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited\&.
.RE
.PP
\fBReturns\fP
.RS 4
xQueueOverwriteFromISR() is a macro that calls xQueueGenericSendFromISR(), and therefore has the same return values as xQueueSendToFrontFromISR()\&. However, pdPASS is the only value that can be returned because xQueueOverwriteFromISR() will write to the queue even when the queue is already full\&.
.RE
.PP
Example usage: 
.PP
.nf


 QueueHandle_t xQueue;

 void vFunction( void *pvParameters )
 {
    // Create a queue to hold one uint32_t value\&.  It is strongly
    // recommended *not* to use xQueueOverwriteFromISR() on queues that can
    // contain more than one value, and doing so will trigger an assertion
    // if configASSERT() is defined\&.
    xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
}

void vAnInterruptHandler( void )
{
// xHigherPriorityTaskWoken must be set to pdFALSE before it is used\&.
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
uint32_t ulVarToSend, ulValReceived;

    // Write the value 10 to the queue using xQueueOverwriteFromISR()\&.
    ulVarToSend = 10;
    xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );

    // The queue is full, but calling xQueueOverwriteFromISR() again will still
    // pass because the value held in the queue will be overwritten with the
    // new value\&.
    ulVarToSend = 100;
    xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );

    // Reading from the queue will now return 100\&.

    // \&.\&.\&.

    if( xHigherPrioritytaskWoken == pdTRUE )
    {
        // Writing to the queue caused a task to unblock and the unblocked task
        // has a priority higher than or equal to the priority of the currently
        // executing task (the task this interrupt interrupted)\&.  Perform a context
        // switch so this interrupt returns directly to the unblocked task\&.
        portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port\&.
    }
}
 
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
