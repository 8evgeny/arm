.TH "xTaskNotify" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xTaskNotify \- xTaskNotify
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
task\&. h 
.PP
.nf
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );
.fi
.PP
.PP
configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available\&.
.PP
When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private 'notification value', which is a 32-bit unsigned integer (uint32_t)\&.
.PP
Events can be sent to a task using an intermediary object\&. Examples of such objects are queues, semaphores, mutexes and event groups\&. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object\&.
.PP
A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value\&. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores\&.
.PP
A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake()\&. If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared\&.
.PP
A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value\&. The task does not consume any CPU time while it is in the Blocked state\&.
.PP
See http://www.FreeRTOS.org/RTOS-task-notifications.html for details\&.
.PP
\fBParameters\fP
.RS 4
\fIxTaskToNotify\fP The handle of the task being notified\&. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle()\&.
.br
\fIulValue\fP Data that can be sent with the notification\&. How the data is used depends on the value of the eAction parameter\&.
.br
\fIeAction\fP Specifies how the notification updates the task's notification value, if at all\&. Valid values for eAction are as follows:
.RE
.PP
eSetBits - The task's notification value is bitwise ORed with ulValue\&. xTaskNofify() always returns pdPASS in this case\&.
.PP
eIncrement - The task's notification value is incremented\&. ulValue is not used and xTaskNotify() always returns pdPASS in this case\&.
.PP
eSetValueWithOverwrite - The task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending)\&. xTaskNotify() always returns pdPASS in this case\&.
.PP
eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS\&. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned\&.
.PP
eNoAction - The task receives a notification without its notification value being updated\&. ulValue is not used and xTaskNotify() always returns pdPASS in this case\&.
.PP
pulPreviousNotificationValue - Can be used to pass out the subject task's notification value before any bits are modified by the notify function\&.
.PP
\fBReturns\fP
.RS 4
Dependent on the value of eAction\&. See the description of the eAction parameter\&.
.RE
.PP
task\&. h 
.PP
.nf
BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
.fi
.PP
.PP
configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available\&.
.PP
When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private 'notification value', which is a 32-bit unsigned integer (uint32_t)\&.
.PP
A version of xTaskNotify() that can be used from an interrupt service routine (ISR)\&.
.PP
Events can be sent to a task using an intermediary object\&. Examples of such objects are queues, semaphores, mutexes and event groups\&. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object\&.
.PP
A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value\&. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores\&.
.PP
A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake()\&. If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared\&.
.PP
A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value\&. The task does not consume any CPU time while it is in the Blocked state\&.
.PP
See http://www.FreeRTOS.org/RTOS-task-notifications.html for details\&.
.PP
\fBParameters\fP
.RS 4
\fIxTaskToNotify\fP The handle of the task being notified\&. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle()\&.
.br
\fIulValue\fP Data that can be sent with the notification\&. How the data is used depends on the value of the eAction parameter\&.
.br
\fIeAction\fP Specifies how the notification updates the task's notification value, if at all\&. Valid values for eAction are as follows:
.RE
.PP
eSetBits - The task's notification value is bitwise ORed with ulValue\&. xTaskNofify() always returns pdPASS in this case\&.
.PP
eIncrement - The task's notification value is incremented\&. ulValue is not used and xTaskNotify() always returns pdPASS in this case\&.
.PP
eSetValueWithOverwrite - The task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending)\&. xTaskNotify() always returns pdPASS in this case\&.
.PP
eSetValueWithoutOverwrite - If the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS\&. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned\&.
.PP
eNoAction - The task receives a notification without its notification value being updated\&. ulValue is not used and xTaskNotify() always returns pdPASS in this case\&.
.PP
\fBParameters\fP
.RS 4
\fIpxHigherPriorityTaskWoken\fP xTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task\&. If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited\&. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use\&.
.RE
.PP
\fBReturns\fP
.RS 4
Dependent on the value of eAction\&. See the description of the eAction parameter\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
