.TH "xTaskCreateStatic" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xTaskCreateStatic \- xTaskCreateStatic
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
task\&. h 
.PP
.nf

TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
                             const char * const pcName,
                             uint32_t ulStackDepth,
                             void *pvParameters,
                             UBaseType_t uxPriority,
                             StackType_t *pxStackBuffer,
                             StaticTask_t *pxTaskBuffer );
.fi
.PP
.PP
Create a new task and add it to the list of tasks that are ready to run\&.
.PP
Internally, within the FreeRTOS implementation, tasks use two blocks of memory\&. The first block is used to hold the task's data structures\&. The second block is used by the task as its stack\&. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function\&. (see http://www.freertos.org/a00111.html)\&. If a task is created using xTaskCreateStatic() then the application writer must provide the required memory\&. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation\&.
.PP
\fBParameters\fP
.RS 4
\fIpvTaskCode\fP Pointer to the task entry function\&. Tasks must be implemented to never return (i\&.e\&. continuous loop)\&.
.br
\fIpcName\fP A descriptive name for the task\&. This is mainly used to facilitate debugging\&. The maximum length of the string is defined by configMAX_TASK_NAME_LEN in \fBFreeRTOSConfig\&.h\fP\&.
.br
\fIulStackDepth\fP The size of the task stack specified as the number of variables the stack can hold - not the number of bytes\&. For example, if the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes will be allocated for stack storage\&.
.br
\fIpvParameters\fP Pointer that will be used as the parameter for the task being created\&.
.br
\fIuxPriority\fP The priority at which the task will run\&.
.br
\fIpxStackBuffer\fP Must point to a StackType_t array that has at least ulStackDepth indexes - the array will then be used as the task's stack, removing the need for the stack to be allocated dynamically\&.
.br
\fIpxTaskBuffer\fP Must point to a variable of type StaticTask_t, which will then be used to hold the task's data structures, removing the need for the memory to be allocated dynamically\&.
.RE
.PP
\fBReturns\fP
.RS 4
If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and pdPASS is returned\&. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned\&.
.RE
.PP
Example usage: 
.PP
.nf


   // Dimensions the buffer that the task being created will use as its stack\&.
   // NOTE:  This is the number of words the stack will hold, not the number of
   // bytes\&.  For example, if each stack item is 32-bits, and this is set to 100,
   // then 400 bytes (100 * 32-bits) will be allocated\&.
   #define STACK_SIZE 200

   // Structure that will hold the TCB of the task being created\&.
   StaticTask_t xTaskBuffer;

   // Buffer that the task being created will use as its stack\&.  Note this is
   // an array of StackType_t variables\&.  The size of StackType_t is dependent on
   // the RTOS port\&.
   StackType_t xStack[ STACK_SIZE ];

   // Function that implements the task being created\&.
   void vTaskCode( void * pvParameters )
   {
       // The parameter value is expected to be 1 as 1 is passed in the
       // pvParameters value in the call to xTaskCreateStatic()\&.
       configASSERT( ( uint32_t ) pvParameters == 1UL );

       for( ;; )
       {
           // Task code goes here\&.
       }
   }

   // Function that creates a task\&.
   void vOtherFunction( void )
   {
       TaskHandle_t xHandle = NULL;

       // Create the task without using any dynamic memory allocation\&.
       xHandle = xTaskCreateStatic(
                     vTaskCode,       // Function that implements the task\&.
                     'NAME',          // Text name for the task\&.
                     STACK_SIZE,      // Stack size in words, not bytes\&.
                     ( void * ) 1,    // Parameter passed into the task\&.
                     tskIDLE_PRIORITY,// Priority at which the task is created\&.
                     xStack,          // Array to use as the task's stack\&.
                     &xTaskBuffer );  // Variable to hold the task's data structure\&.

       // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
       // been created, and xHandle will be the task's handle\&.  Use the handle
       // to suspend the task\&.
       vTaskSuspend( xHandle );
   }
  
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
