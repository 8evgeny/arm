.TH "vTaskEndScheduler" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vTaskEndScheduler \- vTaskEndScheduler
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
task\&. h 
.PP
.nf
void vTaskEndScheduler( void );
.fi
.PP
.PP
NOTE: At the time of writing only the x86 real mode port, which runs on a PC in place of DOS, implements this function\&.
.PP
Stops the real time kernel tick\&. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop\&. Execution then resumes from the point where vTaskStartScheduler () was called, as if vTaskStartScheduler () had just returned\&.
.PP
See the demo application file main\&. c in the demo/PC directory for an example that uses vTaskEndScheduler ()\&.
.PP
vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port\&. c for the PC port)\&. This performs hardware specific operations such as stopping the kernel tick\&.
.PP
vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks\&.
.PP
Example usage: 
.PP
.nf

void vTaskCode( void * pvParameters )
{
    for( ;; )
    {
     // Task code goes here\&.

     // At some point we want to end the real time kernel processing
     // so call \&.\&.\&.
     vTaskEndScheduler ();
    }
}

void vAFunction( void )
{
    // Create at least one task before starting the kernel\&.
    xTaskCreate( vTaskCode, 'NAME', STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );

    // Start the real time kernel with preemption\&.
    vTaskStartScheduler ();

    // Will only get here when the vTaskCode () task has called
    // vTaskEndScheduler ()\&.  When we get here we are back to single task
    // execution\&.
}
  
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
