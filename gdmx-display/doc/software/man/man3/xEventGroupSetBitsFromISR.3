.TH "xEventGroupSetBitsFromISR" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xEventGroupSetBitsFromISR \- xEventGroupSetBitsFromISR
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
\fBevent_groups\&.h\fP 
.PP
.nf

   BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );
.fi
.PP
.PP
A version of xEventGroupSetBits() that can be called from an interrupt\&.
.PP
Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set\&. FreeRTOS does not allow nondeterministic operations to be performed in interrupts or from critical sections\&. Therefore xEventGroupSetBitsFromISR() sends a message to the timer task to have the set operation performed in the context of the timer task - where a scheduler lock is used in place of a critical section\&.
.PP
\fBParameters\fP
.RS 4
\fIxEventGroup\fP The event group in which the bits are to be set\&.
.br
\fIuxBitsToSet\fP A bitwise value that indicates the bit or bits to set\&. For example, to set bit 3 only, set uxBitsToSet to 0x08\&. To set bit 3 and bit 0 set uxBitsToSet to 0x09\&.
.br
\fIpxHigherPriorityTaskWoken\fP As mentioned above, calling this function will result in a message being sent to the timer daemon task\&. If the priority of the timer daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits\&. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE\&. See the example code below\&.
.RE
.PP
\fBReturns\fP
.RS 4
If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned\&. pdFALSE will be returned if the timer service queue was full\&.
.RE
.PP
Example usage: 
.PP
.nf

  #define BIT_0 ( 1 << 0 )
  #define BIT_4 ( 1 << 4 )

  // An event group which it is assumed has already been created by a call to
  // xEventGroupCreate()\&.
  EventGroupHandle_t xEventGroup;

  void anInterruptHandler( void )
  {
  BaseType_t xHigherPriorityTaskWoken, xResult;

    // xHigherPriorityTaskWoken must be initialised to pdFALSE\&.
    xHigherPriorityTaskWoken = pdFALSE;

    // Set bit 0 and bit 4 in xEventGroup\&.
    xResult = xEventGroupSetBitsFromISR(
                        xEventGroup,    // The event group being updated\&.
                        BIT_0 | BIT_4   // The bits being set\&.
                        &xHigherPriorityTaskWoken );

    // Was the message posted successfully?
    if( xResult == pdPASS )
    {
        // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
        // switch should be requested\&.  The macro used is port specific and
        // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
        // refer to the documentation page for the port being used\&.
        portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    }
 }
  
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
