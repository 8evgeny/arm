.TH "xSemaphoreGiveFromISR" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xSemaphoreGiveFromISR \- xSemaphoreGiveFromISR
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
semphr\&. h 
.PP
.nf

xSemaphoreGiveFromISR(
                         SemaphoreHandle_t xSemaphore,
                         BaseType_t *pxHigherPriorityTaskWoken
                     )
.fi
.PP
.PP
\fIMacro\fP to release a semaphore\&. The semaphore must have previously been created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting()\&.
.PP
Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro\&.
.PP
This macro can be used from an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxSemaphore\fP A handle to the semaphore being released\&. This is the handle returned when the semaphore was created\&.
.br
\fIpxHigherPriorityTaskWoken\fP xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task\&. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL\&.
.RE
.PP
Example usage: 
.PP
.nf

#define LONG_TIME 0xffff
#define TICKS_TO_WAIT  10
SemaphoreHandle_t xSemaphore = NULL;

// Repetitive task\&.
void vATask( void * pvParameters )
{
   for( ;; )
   {
       // We want this task to run every 10 ticks of a timer\&.  The semaphore
       // was created before this task was started\&.

       // Block waiting for the semaphore to become available\&.
       if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
       {
           // It is time to execute\&.

           // \&.\&.\&.

           // We have finished our task\&.  Return to the top of the loop where
           // we will block on the semaphore until it is time to execute
           // again\&.  Note when using the semaphore for synchronisation with an
        // ISR in this manner there is no need to 'give' the semaphore back\&.
       }
   }
}

// Timer ISR
void vTimerISR( void * pvParameters )
{
static uint8_t ucLocalTickCount = 0;
static BaseType_t xHigherPriorityTaskWoken;

   // A timer tick has occurred\&.

   // \&.\&.\&. Do other time functions\&.

   // Is it time for vATask () to run?
   xHigherPriorityTaskWoken = pdFALSE;
   ucLocalTickCount++;
   if( ucLocalTickCount >= TICKS_TO_WAIT )
   {
       // Unblock the task by releasing the semaphore\&.
       xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );

       // Reset the count so we release the semaphore again in 10 ticks time\&.
       ucLocalTickCount = 0;
   }

   if( xHigherPriorityTaskWoken != pdFALSE )
   {
       // We can force a context switch here\&.  Context switching from an
       // ISR uses port specific syntax\&.  Check the demo task for your port
       // to find the syntax required\&.
   }
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
