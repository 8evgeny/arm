.TH "crDELAY" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
crDELAY \- crDELAY
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
croutine\&. h 
.PP
.nf

crDELAY( CoRoutineHandle_t xHandle, TickType_t xTicksToDelay );
.fi
.PP
.PP
Delay a co-routine for a fixed period of time\&.
.PP
crDELAY can only be called from the co-routine function itself - not from within a function called by the co-routine function\&. This is because co-routines do not maintain their own stack\&.
.PP
\fBParameters\fP
.RS 4
\fIxHandle\fP The handle of the co-routine to delay\&. This is the xHandle parameter of the co-routine function\&.
.br
\fIxTickToDelay\fP The number of ticks that the co-routine should delay for\&. The actual amount of time this equates to is defined by configTICK_RATE_HZ (set in \fBFreeRTOSConfig\&.h\fP)\&. The constant portTICK_PERIOD_MS can be used to convert ticks to milliseconds\&.
.RE
.PP
Example usage: 
.PP
.nf

// Co-routine to be created\&.
void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
// Variables in co-routines must be declared static if they must maintain value across a blocking call\&.
// This may not be necessary for const variables\&.
// We are to delay for 200ms\&.
static const xTickType xDelayTime = 200 / portTICK_PERIOD_MS;

    // Must start every co-routine with a call to crSTART();
    crSTART( xHandle );

    for( ;; )
    {
       // Delay for 200ms\&.
       crDELAY( xHandle, xDelayTime );

       // Do something here\&.
    }

    // Must end every co-routine with a call to crEND();
    crEND();
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
