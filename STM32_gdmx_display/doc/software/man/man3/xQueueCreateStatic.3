.TH "xQueueCreateStatic" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xQueueCreateStatic \- xQueueCreateStatic
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
queue\&. h 
.PP
.nf

QueueHandle_t xQueueCreateStatic(
                          UBaseType_t uxQueueLength,
                          UBaseType_t uxItemSize,
                          uint8_t *pucQueueStorageBuffer,
                          StaticQueue_t *pxQueueBuffer
                      );
  
.fi
.PP
.PP
Creates a new queue instance, and returns a handle by which the new queue can be referenced\&.
.PP
Internally, within the FreeRTOS implementation, queues use two blocks of memory\&. The first block is used to hold the queue's data structures\&. The second block is used to hold items placed into the queue\&. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function\&. (see http://www.freertos.org/a00111.html)\&. If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue\&. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation\&.
.PP
http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
.PP
\fBParameters\fP
.RS 4
\fIuxQueueLength\fP The maximum number of items that the queue can contain\&.
.br
\fIuxItemSize\fP The number of bytes each item in the queue will require\&. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item\&. Each item on the queue must be the same size\&.
.br
\fIpucQueueStorageBuffer\fP If uxItemSize is not zero then pucQueueStorageBuffer must point to a uint8_t array that is at least large enough to hold the maximum number of items that can be in the queue at any one time - which is ( uxQueueLength * uxItemsSize ) bytes\&. If uxItemSize is zero then pucQueueStorageBuffer can be NULL\&.
.br
\fIpxQueueBuffer\fP Must point to a variable of type StaticQueue_t, which will be used to hold the queue's data structure\&.
.RE
.PP
\fBReturns\fP
.RS 4
If the queue is created then a handle to the created queue is returned\&. If pxQueueBuffer is NULL then NULL is returned\&.
.RE
.PP
Example usage: 
.PP
.nf

struct AMessage
{
   char ucMessageID;
   char ucData[ 20 ];
};

#define QUEUE_LENGTH 10
#define ITEM_SIZE sizeof( uint32_t )

// xQueueBuffer will hold the queue structure\&.
StaticQueue_t xQueueBuffer;

// ucQueueStorage will hold the items posted to the queue\&.  Must be at least
// [(queue length) * ( queue item size)] bytes long\&.
uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1;

   // Create a queue capable of containing 10 uint32_t values\&.
   xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold\&.
                        ITEM_SIZE     // The size of each item in the queue
                        &( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue\&.
                        &xQueueBuffer ); // The buffer that will hold the queue structure\&.

   // The queue is guaranteed to be created successfully as no dynamic memory
   // allocation is used\&.  Therefore xQueue1 is now a handle to a valid queue\&.

   // \&.\&.\&. Rest of task code\&.
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
