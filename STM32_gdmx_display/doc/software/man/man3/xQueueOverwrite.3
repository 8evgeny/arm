.TH "xQueueOverwrite" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xQueueOverwrite \- xQueueOverwrite
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
queue\&. h 
.PP
.nf

 BaseType_t xQueueOverwrite(
                              QueueHandle_t xQueue,
                              const void * pvItemToQueue
                         );
   
.fi
.PP
.PP
Only for use with queues that have a length of one - so the queue is either empty or full\&.
.PP
Post an item on a queue\&. If the queue is already full then overwrite the value held in the queue\&. The item is queued by copy, not by reference\&.
.PP
This function must not be called from an interrupt service routine\&. See xQueueOverwriteFromISR () for an alternative which may be used in an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle of the queue to which the data is being sent\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.RE
.PP
\fBReturns\fP
.RS 4
xQueueOverwrite() is a macro that calls xQueueGenericSend(), and therefore has the same return values as xQueueSendToFront()\&. However, pdPASS is the only value that can be returned because xQueueOverwrite() will write to the queue even when the queue is already full\&.
.RE
.PP
Example usage: 
.PP
.nf


 void vFunction( void *pvParameters )
 {
 QueueHandle_t xQueue;
 uint32_t ulVarToSend, ulValReceived;

    // Create a queue to hold one uint32_t value\&.  It is strongly
    // recommended *not* to use xQueueOverwrite() on queues that can
    // contain more than one value, and doing so will trigger an assertion
    // if configASSERT() is defined\&.
    xQueue = xQueueCreate( 1, sizeof( uint32_t ) );

    // Write the value 10 to the queue using xQueueOverwrite()\&.
    ulVarToSend = 10;
    xQueueOverwrite( xQueue, &ulVarToSend );

    // Peeking the queue should now return 10, but leave the value 10 in
    // the queue\&.  A block time of zero is used as it is known that the
    // queue holds a value\&.
    ulValReceived = 0;
    xQueuePeek( xQueue, &ulValReceived, 0 );

    if( ulValReceived != 10 )
    {
        // Error unless the item was removed by a different task\&.
    }

    // The queue is still full\&.  Use xQueueOverwrite() to overwrite the
    // value held in the queue with 100\&.
    ulVarToSend = 100;
    xQueueOverwrite( xQueue, &ulVarToSend );

    // This time read from the queue, leaving the queue empty once more\&.
    // A block time of 0 is used again\&.
    xQueueReceive( xQueue, &ulValReceived, 0 );

    // The value read should be the last value written, even though the
    // queue was already full when the value was written\&.
    if( ulValReceived != 100 )
    {
        // Error!
    }

    // \&.\&.\&.
}
 
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
