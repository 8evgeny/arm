.TH "xSemaphoreCreateCounting" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xSemaphoreCreateCounting \- xSemaphoreCreateCounting
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
semphr\&. h 
.PP
.nf
SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )
.fi
.PP
.PP
Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced\&.
.PP
In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! http://www.freertos.org/RTOS-task-notifications.html
.PP
Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored\&. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function\&. (see http://www.freertos.org/a00111.html)\&. If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer can instead optionally provide the memory that will get used by the counting semaphore\&. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation\&.
.PP
Counting semaphores are typically used for two things:
.PP
1) Counting events\&.
.PP
In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value)\&. The count value is therefore the difference between the number of events that have occurred and the number that have been processed\&. In this case it is desirable for the initial count value to be zero\&.
.PP
2) Resource management\&.
.PP
In this usage scenario the count value indicates the number of resources available\&. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value\&. When the count value reaches zero there are no free resources\&. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value\&. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free\&.
.PP
\fBParameters\fP
.RS 4
\fIuxMaxCount\fP The maximum count value that can be reached\&. When the semaphore reaches this value it can no longer be 'given'\&.
.br
\fIuxInitialCount\fP The count value assigned to the semaphore when it is created\&.
.RE
.PP
\fBReturns\fP
.RS 4
Handle to the created semaphore\&. Null if the semaphore could not be created\&.
.RE
.PP
Example usage: 
.PP
.nf

SemaphoreHandle_t xSemaphore;

void vATask( void * pvParameters )
{
SemaphoreHandle_t xSemaphore = NULL;

   // Semaphore cannot be used before a call to xSemaphoreCreateCounting()\&.
   // The max value to which the semaphore can count should be 10, and the
   // initial value assigned to the count should be 0\&.
   xSemaphore = xSemaphoreCreateCounting( 10, 0 );

   if( xSemaphore != NULL )
   {
       // The semaphore was created successfully\&.
       // The semaphore can now be used\&.
   }
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
