.TH "xSemaphoreCreateMutexStatic" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xSemaphoreCreateMutexStatic \- xSemaphoreCreateMutexStatic
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
semphr\&. h 
.PP
.nf
SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )
.fi
.PP
.PP
Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced\&.
.PP
Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored\&. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function\&. (see http://www.freertos.org/a00111.html)\&. If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory\&. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation\&.
.PP
Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros\&. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used\&.
.PP
This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required\&.
.PP
Mutex type semaphores cannot be used from within interrupt service routines\&.
.PP
See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines\&.
.PP
\fBParameters\fP
.RS 4
\fIpxMutexBuffer\fP Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex's data structure, removing the need for the memory to be allocated dynamically\&.
.RE
.PP
\fBReturns\fP
.RS 4
If the mutex was successfully created then a handle to the created mutex is returned\&. If pxMutexBuffer was NULL then NULL is returned\&.
.RE
.PP
Example usage: 
.PP
.nf

SemaphoreHandle_t xSemaphore;
StaticSemaphore_t xMutexBuffer;

void vATask( void * pvParameters )
{
   // A mutex cannot be used before it has been created\&.  xMutexBuffer is
   // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
   // attempted\&.
   xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );

   // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
   // so there is no need to check it\&.
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
