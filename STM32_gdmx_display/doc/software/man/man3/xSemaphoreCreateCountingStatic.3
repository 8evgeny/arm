.TH "xSemaphoreCreateCountingStatic" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xSemaphoreCreateCountingStatic \- xSemaphoreCreateCountingStatic
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
semphr\&. h 
.PP
.nf
SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )
.fi
.PP
.PP
Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced\&.
.PP
In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! http://www.freertos.org/RTOS-task-notifications.html
.PP
Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored\&. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function\&. (see http://www.freertos.org/a00111.html)\&. If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer must provide the memory\&. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation\&.
.PP
Counting semaphores are typically used for two things:
.PP
1) Counting events\&.
.PP
In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value)\&. The count value is therefore the difference between the number of events that have occurred and the number that have been processed\&. In this case it is desirable for the initial count value to be zero\&.
.PP
2) Resource management\&.
.PP
In this usage scenario the count value indicates the number of resources available\&. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value\&. When the count value reaches zero there are no free resources\&. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value\&. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free\&.
.PP
\fBParameters\fP
.RS 4
\fIuxMaxCount\fP The maximum count value that can be reached\&. When the semaphore reaches this value it can no longer be 'given'\&.
.br
\fIuxInitialCount\fP The count value assigned to the semaphore when it is created\&.
.br
\fIpxSemaphoreBuffer\fP Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore's data structure, removing the need for the memory to be allocated dynamically\&.
.RE
.PP
\fBReturns\fP
.RS 4
If the counting semaphore was successfully created then a handle to the created counting semaphore is returned\&. If pxSemaphoreBuffer was NULL then NULL is returned\&.
.RE
.PP
Example usage: 
.PP
.nf

SemaphoreHandle_t xSemaphore;
StaticSemaphore_t xSemaphoreBuffer;

void vATask( void * pvParameters )
{
SemaphoreHandle_t xSemaphore = NULL;

   // Counting semaphore cannot be used before they have been created\&.  Create
   // a counting semaphore using xSemaphoreCreateCountingStatic()\&.  The max
   // value to which the semaphore can count is 10, and the initial value
   // assigned to the count will be 0\&.  The address of xSemaphoreBuffer is
   // passed in and will be used to hold the semaphore structure, so no dynamic
   // memory allocation will be used\&.
   xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );

   // No memory allocation was attempted so xSemaphore cannot be NULL, so there
   // is no need to check its value\&.
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
