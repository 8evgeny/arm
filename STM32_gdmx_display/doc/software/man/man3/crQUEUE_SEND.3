.TH "crQUEUE_SEND" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
crQUEUE_SEND \- crQUEUE_SEND
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 

.PP
.nf

crQUEUE_SEND(
                 CoRoutineHandle_t xHandle,
                 QueueHandle_t pxQueue,
                 void *pvItemToQueue,
                 TickType_t xTicksToWait,
                 BaseType_t *pxResult
            )
.fi
.PP
.PP
The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine equivalent to the xQueueSend() and xQueueReceive() functions used by tasks\&.
.PP
crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas xQueueSend() and xQueueReceive() can only be used from tasks\&.
.PP
crQUEUE_SEND can only be called from the co-routine function itself - not from within a function called by the co-routine function\&. This is because co-routines do not maintain their own stack\&.
.PP
See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines\&.
.PP
\fBParameters\fP
.RS 4
\fIxHandle\fP The handle of the calling co-routine\&. This is the xHandle parameter of the co-routine function\&.
.br
\fIpxQueue\fP The handle of the queue on which the data will be posted\&. The handle is obtained as the return value when the queue is created using the xQueueCreate() API function\&.
.br
\fIpvItemToQueue\fP A pointer to the data being posted onto the queue\&. The number of bytes of each queued item is specified when the queue is created\&. This number of bytes is copied from pvItemToQueue into the queue itself\&.
.br
\fIxTickToDelay\fP The number of ticks that the co-routine should block to wait for space to become available on the queue, should space not be available immediately\&. The actual amount of time this equates to is defined by configTICK_RATE_HZ (set in \fBFreeRTOSConfig\&.h\fP)\&. The constant portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example below)\&.
.br
\fIpxResult\fP The variable pointed to by pxResult will be set to pdPASS if data was successfully posted onto the queue, otherwise it will be set to an error defined within \fBProjDefs\&.h\fP\&.
.RE
.PP
Example usage: 
.PP
.nf

// Co-routine function that blocks for a fixed period then posts a number onto
// a queue\&.
static void prvCoRoutineFlashTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
// Variables in co-routines must be declared static if they must maintain value across a blocking call\&.
static BaseType_t xNumberToPost = 0;
static BaseType_t xResult;

   // Co-routines must begin with a call to crSTART()\&.
   crSTART( xHandle );

   for( ;; )
   {
       // This assumes the queue has already been created\&.
       crQUEUE_SEND( xHandle, xCoRoutineQueue, &xNumberToPost, NO_DELAY, &xResult );

       if( xResult != pdPASS )
       {
           // The message was not posted!
       }

       // Increment the number to be posted onto the queue\&.
       xNumberToPost++;

       // Delay for 100 ticks\&.
       crDELAY( xHandle, 100 );
   }

   // Co-routines must end with a call to crEND()\&.
   crEND();
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
