.TH "crQUEUE_RECEIVE_FROM_ISR" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
crQUEUE_RECEIVE_FROM_ISR \- crQUEUE_RECEIVE_FROM_ISR
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
croutine\&. h 
.PP
.nf

 crQUEUE_SEND_FROM_ISR(
                           QueueHandle_t pxQueue,
                           void *pvBuffer,
                           BaseType_t * pxCoRoutineWoken
                      )
.fi
.PP
.PP
The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR() functions used by tasks\&.
.PP
crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and xQueueReceiveFromISR() can only be used to pass data between a task and and ISR\&.
.PP
crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data from a queue that is being used from within a co-routine (a co-routine posted to the queue)\&.
.PP
See the co-routine section of the WEB documentation for information on passing data between tasks and co-routines and between ISR's and co-routines\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvBuffer\fP A pointer to a buffer into which the received item will be placed\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from the queue into pvBuffer\&.
.br
\fIpxCoRoutineWoken\fP A co-routine may be blocked waiting for space to become available on the queue\&. If crQUEUE_RECEIVE_FROM_ISR causes such a co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise *pxCoRoutineWoken will remain unchanged\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE an item was successfully received from the queue, otherwise pdFALSE\&.
.RE
.PP
Example usage: 
.PP
.nf

// A co-routine that posts a character to a queue then blocks for a fixed
// period\&.  The character is incremented each time\&.
static void vSendingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
// cChar holds its value while this co-routine is blocked and must therefore
// be declared static\&.
static char cCharToTx = 'a';
BaseType_t xResult;

    // All co-routines must start with a call to crSTART()\&.
    crSTART( xHandle );

    for( ;; )
    {
        // Send the next character to the queue\&.
        crQUEUE_SEND( xHandle, xCoRoutineQueue, &cCharToTx, NO_DELAY, &xResult );

        if( xResult == pdPASS )
        {
            // The character was successfully posted to the queue\&.
        }
     else
     {
        // Could not post the character to the queue\&.
     }

        // Enable the UART Tx interrupt to cause an interrupt in this
     // hypothetical UART\&.  The interrupt will obtain the character
     // from the queue and send it\&.
     ENABLE_RX_INTERRUPT();

     // Increment to the next character then block for a fixed period\&.
     // cCharToTx will maintain its value across the delay as it is
     // declared static\&.
     cCharToTx++;
     if( cCharToTx > 'x' )
     {
        cCharToTx = 'a';
     }
     crDELAY( 100 );
    }

    // All co-routines must end with a call to crEND()\&.
    crEND();
}

// An ISR that uses a queue to receive characters to send on a UART\&.
void vUART_ISR( void )
{
char cCharToTx;
BaseType_t xCRWokenByPost = pdFALSE;

    while( UART_TX_REG_EMPTY() )
    {
        // Are there any characters in the queue waiting to be sent?
     // xCRWokenByPost will automatically be set to pdTRUE if a co-routine
     // is woken by the post - ensuring that only a single co-routine is
     // woken no matter how many times we go around this loop\&.
        if( crQUEUE_RECEIVE_FROM_ISR( pxQueue, &cCharToTx, &xCRWokenByPost ) )
     {
         SEND_CHARACTER( cCharToTx );
     }
    }
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
