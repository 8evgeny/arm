.TH "xQueueSend" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xQueueSend \- xQueueSend
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
queue\&. h 
.PP
.nf

BaseType_t xQueueSendToToFront(
                               QueueHandle_t    xQueue,
                               const void       *pvItemToQueue,
                               TickType_t       xTicksToWait
                           );
  
.fi
.PP
.PP
Post an item to the front of a queue\&. The item is queued by copy, not by reference\&. This function must not be called from an interrupt service routine\&. See xQueueSendFromISR () for an alternative which may be used in an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.br
\fIxTicksToWait\fP The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full\&. The call will return immediately if this is set to 0 and the queue is full\&. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL\&.
.RE
.PP
Example usage: 
.PP
.nf

struct AMessage
{
   char ucMessageID;
   char ucData[ 20 ];
} xMessage;

uint32_t ulVar = 10UL;

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1, xQueue2;
struct AMessage *pxMessage;

   // Create a queue capable of containing 10 uint32_t values\&.
   xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );

   // Create a queue capable of containing 10 pointers to AMessage structures\&.
   // These should be passed by pointer as they contain a lot of data\&.
   xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

   // \&.\&.\&.

   if( xQueue1 != 0 )
   {
    // Send an uint32_t\&.  Wait for 10 ticks for space to become
    // available if necessary\&.
    if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
    {
        // Failed to post the message, even after 10 ticks\&.
    }
   }

   if( xQueue2 != 0 )
   {
    // Send a pointer to a struct AMessage object\&.  Don't block if the
    // queue is already full\&.
    pxMessage = & xMessage;
    xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
   }

   // \&.\&.\&. Rest of task code\&.
}
.fi
.PP
.PP
queue\&. h 
.PP
.nf

BaseType_t xQueueSendToBack(
                               QueueHandle_t    xQueue,
                               const void       *pvItemToQueue,
                               TickType_t       xTicksToWait
                           );
  
.fi
.PP
.PP
This is a macro that calls xQueueGenericSend()\&.
.PP
Post an item to the back of a queue\&. The item is queued by copy, not by reference\&. This function must not be called from an interrupt service routine\&. See xQueueSendFromISR () for an alternative which may be used in an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.br
\fIxTicksToWait\fP The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full\&. The call will return immediately if this is set to 0 and the queue is full\&. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL\&.
.RE
.PP
Example usage: 
.PP
.nf

struct AMessage
{
   char ucMessageID;
   char ucData[ 20 ];
} xMessage;

uint32_t ulVar = 10UL;

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1, xQueue2;
struct AMessage *pxMessage;

   // Create a queue capable of containing 10 uint32_t values\&.
   xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );

   // Create a queue capable of containing 10 pointers to AMessage structures\&.
   // These should be passed by pointer as they contain a lot of data\&.
   xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

   // \&.\&.\&.

   if( xQueue1 != 0 )
   {
    // Send an uint32_t\&.  Wait for 10 ticks for space to become
    // available if necessary\&.
    if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
    {
        // Failed to post the message, even after 10 ticks\&.
    }
   }

   if( xQueue2 != 0 )
   {
    // Send a pointer to a struct AMessage object\&.  Don't block if the
    // queue is already full\&.
    pxMessage = & xMessage;
    xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
   }

   // \&.\&.\&. Rest of task code\&.
}
.fi
.PP
.PP
queue\&. h 
.PP
.nf

BaseType_t xQueueSend(
                          QueueHandle_t xQueue,
                          const void * pvItemToQueue,
                          TickType_t xTicksToWait
                     );
  
.fi
.PP
.PP
This is a macro that calls xQueueGenericSend()\&. It is included for backward compatibility with versions of FreeRTOS\&.org that did not include the xQueueSendToFront() and xQueueSendToBack() macros\&. It is equivalent to xQueueSendToBack()\&.
.PP
Post an item on a queue\&. The item is queued by copy, not by reference\&. This function must not be called from an interrupt service routine\&. See xQueueSendFromISR () for an alternative which may be used in an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.br
\fIxTicksToWait\fP The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full\&. The call will return immediately if this is set to 0 and the queue is full\&. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL\&.
.RE
.PP
Example usage: 
.PP
.nf

struct AMessage
{
   char ucMessageID;
   char ucData[ 20 ];
} xMessage;

uint32_t ulVar = 10UL;

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1, xQueue2;
struct AMessage *pxMessage;

   // Create a queue capable of containing 10 uint32_t values\&.
   xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );

   // Create a queue capable of containing 10 pointers to AMessage structures\&.
   // These should be passed by pointer as they contain a lot of data\&.
   xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

   // \&.\&.\&.

   if( xQueue1 != 0 )
   {
    // Send an uint32_t\&.  Wait for 10 ticks for space to become
    // available if necessary\&.
    if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
    {
        // Failed to post the message, even after 10 ticks\&.
    }
   }

   if( xQueue2 != 0 )
   {
    // Send a pointer to a struct AMessage object\&.  Don't block if the
    // queue is already full\&.
    pxMessage = & xMessage;
    xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
   }

   // \&.\&.\&. Rest of task code\&.
}
.fi
.PP
.PP
queue\&. h 
.PP
.nf

BaseType_t xQueueGenericSend(
                                QueueHandle_t xQueue,
                                const void * pvItemToQueue,
                                TickType_t xTicksToWait
                                BaseType_t xCopyPosition
                            );
  
.fi
.PP
.PP
It is preferred that the macros xQueueSend(), xQueueSendToFront() and xQueueSendToBack() are used in place of calling this function directly\&.
.PP
Post an item on a queue\&. The item is queued by copy, not by reference\&. This function must not be called from an interrupt service routine\&. See xQueueSendFromISR () for an alternative which may be used in an ISR\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue on which the item is to be posted\&.
.br
\fIpvItemToQueue\fP A pointer to the item that is to be placed on the queue\&. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area\&.
.br
\fIxTicksToWait\fP The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full\&. The call will return immediately if this is set to 0 and the queue is full\&. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required\&.
.br
\fIxCopyPosition\fP Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages)\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL\&.
.RE
.PP
Example usage: 
.PP
.nf

struct AMessage
{
   char ucMessageID;
   char ucData[ 20 ];
} xMessage;

uint32_t ulVar = 10UL;

void vATask( void *pvParameters )
{
QueueHandle_t xQueue1, xQueue2;
struct AMessage *pxMessage;

   // Create a queue capable of containing 10 uint32_t values\&.
   xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );

   // Create a queue capable of containing 10 pointers to AMessage structures\&.
   // These should be passed by pointer as they contain a lot of data\&.
   xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );

   // \&.\&.\&.

   if( xQueue1 != 0 )
   {
    // Send an uint32_t\&.  Wait for 10 ticks for space to become
    // available if necessary\&.
    if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
    {
        // Failed to post the message, even after 10 ticks\&.
    }
   }

   if( xQueue2 != 0 )
   {
    // Send a pointer to a struct AMessage object\&.  Don't block if the
    // queue is already full\&.
    pxMessage = & xMessage;
    xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
   }

   // \&.\&.\&. Rest of task code\&.
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
