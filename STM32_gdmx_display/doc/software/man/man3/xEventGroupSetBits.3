.TH "xEventGroupSetBits" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xEventGroupSetBits \- xEventGroupSetBits
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
\fBevent_groups\&.h\fP 
.PP
.nf

   EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
.fi
.PP
.PP
Set bits within an event group\&. This function cannot be called from an interrupt\&. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt\&.
.PP
Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits\&.
.PP
\fBParameters\fP
.RS 4
\fIxEventGroup\fP The event group in which the bits are to be set\&.
.br
\fIuxBitsToSet\fP A bitwise value that indicates the bit or bits to set\&. For example, to set bit 3 only, set uxBitsToSet to 0x08\&. To set bit 3 and bit 0 set uxBitsToSet to 0x09\&.
.RE
.PP
\fBReturns\fP
.RS 4
The value of the event group at the time the call to xEventGroupSetBits() returns\&. There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared\&. First, if setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will be cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits())\&. Second, any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns\&.
.RE
.PP
Example usage: 
.PP
.nf

  #define BIT_0 ( 1 << 0 )
  #define BIT_4 ( 1 << 4 )

  void aFunction( EventGroupHandle_t xEventGroup )
  {
  EventBits_t uxBits;

    // Set bit 0 and bit 4 in xEventGroup\&.
    uxBits = xEventGroupSetBits(
                        xEventGroup,    // The event group being updated\&.
                        BIT_0 | BIT_4 );// The bits being set\&.

    if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
    {
        // Both bit 0 and bit 4 remained set when the function returned\&.
    }
    else if( ( uxBits & BIT_0 ) != 0 )
    {
        // Bit 0 remained set when the function returned, but bit 4 was
        // cleared\&.  It might be that bit 4 was cleared automatically as a
        // task that was waiting for bit 4 was removed from the Blocked
        // state\&.
    }
    else if( ( uxBits & BIT_4 ) != 0 )
    {
        // Bit 4 remained set when the function returned, but bit 0 was
        // cleared\&.  It might be that bit 0 was cleared automatically as a
        // task that was waiting for bit 0 was removed from the Blocked
        // state\&.
    }
    else
    {
        // Neither bit 0 nor bit 4 remained set\&.  It might be that a task
        // was waiting for both of the bits to be set, and the bits were
        // cleared as the task left the Blocked state\&.
    }
  }
  
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
