.TH "xQueueReceiveFromISR" 3 "Mon May 24 2021" "gdmx-display" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xQueueReceiveFromISR \- xQueueReceiveFromISR
.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
queue\&. h 
.PP
.nf

BaseType_t xQueueReceiveFromISR(
                                   QueueHandle_t    xQueue,
                                   void *pvBuffer,
                                   BaseType_t *pxTaskWoken
                               );
  
.fi
.PP
.PP
Receive an item from a queue\&. It is safe to use this function from within an interrupt service routine\&.
.PP
\fBParameters\fP
.RS 4
\fIxQueue\fP The handle to the queue from which the item is to be received\&.
.br
\fIpvBuffer\fP Pointer to the buffer into which the received item will be copied\&.
.br
\fIpxTaskWoken\fP A task may be blocked waiting for space to become available on the queue\&. If xQueueReceiveFromISR causes such a task to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will remain unchanged\&.
.RE
.PP
\fBReturns\fP
.RS 4
pdTRUE if an item was successfully received from the queue, otherwise pdFALSE\&.
.RE
.PP
Example usage: 
.PP
.nf


QueueHandle_t xQueue;

// Function to create a queue and post some values\&.
void vAFunction( void *pvParameters )
{
char cValueToPost;
const TickType_t xTicksToWait = ( TickType_t )0xff;

   // Create a queue capable of containing 10 characters\&.
   xQueue = xQueueCreate( 10, sizeof( char ) );
   if( xQueue == 0 )
   {
    // Failed to create the queue\&.
   }

   // \&.\&.\&.

   // Post some characters that will be used within an ISR\&.  If the queue
   // is full then this task will block for xTicksToWait ticks\&.
   cValueToPost = 'a';
   xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
   cValueToPost = 'b';
   xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );

   // \&.\&.\&. keep posting characters \&.\&.\&. this task may block when the queue
   // becomes full\&.

   cValueToPost = 'c';
   xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
}

// ISR that outputs all the characters received on the queue\&.
void vISR_Routine( void )
{
BaseType_t xTaskWokenByReceive = pdFALSE;
char cRxedChar;

   while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
   {
    // A character was received\&.  Output the character now\&.
    vOutputCharacter( cRxedChar );

    // If removing the character from the queue woke the task that was
    // posting onto the queue cTaskWokenByReceive will have been set to
    // pdTRUE\&.  No matter how many times this loop iterates only one
    // task will be woken\&.
   }

   if( cTaskWokenByPost != ( char ) pdFALSE;
   {
    taskYIELD ();
   }
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for gdmx-display from the source code\&.
