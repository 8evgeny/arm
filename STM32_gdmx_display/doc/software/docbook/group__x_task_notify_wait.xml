<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_group__x_task_notify_wait" xml:lang="en-US">
<title>xTaskNotifyWait</title>
<indexterm><primary>xTaskNotifyWait</primary></indexterm>

<para>task. h <literallayout>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</literallayout></para>

<para>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</para>

<para>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private &quot;notification value&quot;, which is a 32-bit unsigned integer (uint32_t).</para>

<para>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</para>

<para>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task&apos;s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</para>

<para>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</para>

<para>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</para>

<para>See <link xlink:href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</link> for details.</para>

<para>
                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>ulBitsToClearOnEntry</entry>
                                <entry>
<para>Bits that are set in ulBitsToClearOnEntry value will be cleared in the calling task&apos;s notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task&apos;s notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the task&apos;s notification value unchanged.</para>
</entry>
                            </row>
                            <row>
                                <entry>ulBitsToClearOnExit</entry>
                                <entry>
<para>If a notification is pending or received before the calling task exits the xTaskNotifyWait() function then the task&apos;s notification value (see the xTaskNotify() API function) is passed out using the pulNotificationValue parameter. Then any bits that are set in ulBitsToClearOnExit will be cleared in the task&apos;s notification value (note *pulNotificationValue is set before any bits are cleared). Setting ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task&apos;s notification value to 0 before the function exits. Setting ulBitsToClearOnExit to 0 will leave the task&apos;s notification value unchanged when the function exits (in which case the value passed out in pulNotificationValue will match the task&apos;s notification value).</para>
</entry>
                            </row>
                            <row>
                                <entry>pulNotificationValue</entry>
                                <entry>
<para>Used to pass the task&apos;s notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ulBitsToClearOnExit being non-zero.</para>
</entry>
                            </row>
                            <row>
                                <entry>xTicksToWait</entry>
                                <entry>
<para>The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when xTaskNotifyWait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned.</para>
</formalpara>
task. h <literallayout>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );

configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
to be available.

When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
&quot;notification value&quot;, which is a 32-bit unsigned integer (uint32_t).

A version of xTaskNotifyGive() that can be called from an interrupt service
routine (ISR).

Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.

A notification sent to a task can optionally perform an action, such as
update, overwrite or increment the task&apos;s notification value.  In that way
task notifications can be used to send data to a task, or be used as light
weight and fast binary or counting semaphores.

vTaskNotifyGiveFromISR() is intended for use when task notifications are
used as light weight and faster binary or counting semaphore equivalents.
Actual FreeRTOS semaphores are given from an ISR using the
xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
a task notification is vTaskNotifyGiveFromISR().

When task notifications are being used as a binary or counting semaphore
equivalent then the task being notified should wait for the notification
using the ulTaskNotificationTake() API function rather than the
xTaskNotifyWait() API function.

See <link xlink:href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</link> for more details.


                <formalpara>
                    <title>
Parameters                    </title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>xTaskToNotify</entry>
                                <entry>
<para>The handle of the task being notified.  The handle to a
task can be returned from the xTaskCreate() API function used to create the
task, and the handle of the currently running task can be obtained by calling
xTaskGetCurrentTaskHandle().

</para>
</entry>
                            </row>
                            <row>
                                <entry>pxHigherPriorityTaskWoken</entry>
                                <entry>
<para> vTaskNotifyGiveFromISR() will set
*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
task to which the notification was sent to leave the Blocked state, and the
unblocked task has a priority higher than the currently running task.  If
vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
should be requested before the interrupt is exited.  How a context switch is
requested from an ISR is dependent on the port - see the documentation page
for the port in use.
</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </literallayout></para>
</section>
